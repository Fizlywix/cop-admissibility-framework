\input{../../../templates/arxiv/arxiv.tex}
\usepackage{../../../templates/cop/cop-macros}
\usepackage{../../../templates/cop/cop-diagrams}
\usepackage{listings}

\title{A3: Computational Realization (Derived Executable Layer)}
\author{Pascal Sparidaens \\ Derived Computational Layer by Zeropoint}
\date{}

\begin{document}
\maketitle

\begin{abstract}
This document presents a derived computational realization
of the COP admissibility framework.
It specifies a minimal executable representation
of directional, ledger, and role indexed constraint operators,
including seam traversal and visibility tagging.
The realization does not interpret or replace
the primary gate formula.
It functions solely as a secondary implementation interface.
No predictive or normative claims are made.
\end{abstract}

\section{Purpose}

This paper demonstrates a simple distinction:
constraint algebras may be implemented
without becoming models of the world.

Its purpose is not to simulate reality,
but to show what becomes visible
when admissibility relations
are represented as executable operators.

\section{What This Demonstration Is Not}

This demonstration does not:
\begin{itemize}
  \item predict outcomes,
  \item validate applications,
  \item recommend actions,
  \item define optimal behavior,
  \item or confer authority to computation.
\end{itemize}

Any reading that treats implementation
as explanation
misunderstands its status.

\section{Computational Objects}

Let $X$ be a finite or discretized configuration space.

Admissibility regions are represented
as subsets of $X$.

Computationally, a region may be encoded as:

\begin{itemize}
  \item a bitset over $X$,
  \item a set of indices,
  \item or a predicate $p:X\rightarrow\{\texttt{true},\texttt{false}\}$.
\end{itemize}

No internal meaning of $X$ is assumed.

\section{Operator Indexing}

Each constraint operator is indexed by:

\[
(D,W,R)\in\{1,2\}\times\{1,2,3,4\}\times\{1,\dots,8\}.
\]

Define a lookup:

\[
\Phi(D,W,R) = f_{D,W,R}.
\]

Operators satisfy contracting monotonic narrowing:

\[
f_{D,W,R}(A)\subseteq A,
\qquad
A\subseteq B \Rightarrow f_{D,W,R}(A)\subseteq f_{D,W,R}(B).
\]

\section{Seam Operators}

Two distinguished operators are implemented:

\begin{itemize}
  \item $S_{\mathrm{in}}$ (ALL0 seam),
  \item $S_{\mathrm{out}}$ (0ALL seam).
\end{itemize}

Seams are operators, not contents.
They regulate admissible cycling by domain restriction.

\section{Visibility Tagging}

Visibility is implemented as a derived function:

\[
Vis(D,W,R)\in\{N,V,B,S\}.
\]

Visibility is not stored as meaning.
It is computed from:

\begin{itemize}
  \item operator type (direction and ledger state),
  \item boundary proximity (closure intensity),
  \item and seam activation.
\end{itemize}

\section{Execution: One Step}

A single admissibility step applies a chosen operator
to the current region.

\begin{lstlisting}[basicstyle=\ttfamily\small]
step(A, D, W, R):
  f = Phi(D,W,R)
  return f(A)
\end{lstlisting}

\section{Execution: Trajectory}

A trajectory is generated by a schedule
(a sequence of coordinates).

\begin{lstlisting}[basicstyle=\ttfamily\small]
run(A0, schedule):
  A = A0
  for (D,W,R) in schedule:
    A = step(A, D, W, R)
    if A == empty:
      break
  return A
\end{lstlisting}

No interpretation is imposed on schedules.
They may be arbitrary, adversarial, or sampled.

\section{Bidirectional Composition}

Bidirectional narrowing may be implemented as:

\subsection{Sequential Form}

\begin{lstlisting}[basicstyle=\ttfamily\small]
compose_seq(A, f, g):
  return g(f(A))
\end{lstlisting}

\subsection{Intersection Form}

\begin{lstlisting}[basicstyle=\ttfamily\small]
compose_meet(A, f, g):
  return intersect(f(A), g(A))
\end{lstlisting}

No preference between forms is imposed.
Both encode admissibility narrowing.

\section{Minimal Engine Loop}

A minimal cycle is implemented as:

\begin{lstlisting}[basicstyle=\ttfamily\small]
engine_loop(A):
  A = Sin(A)                  # ALL0 seam
  A = forward_commits(A)      # W=2
  A = forward_propagate(A)    # W=3
  A = closure_knife_edge(A)   # W=4 boundary
  A = reverse_trace(A)        # W=3 (reverse)
  A = reverse_exclude(A)      # W=2 (reverse)
  A = reverse_infer(A)        # W=4 (reverse)
  A = Sout(A)                 # 0ALL seam
  return A
\end{lstlisting}

This implementation encodes closure without restoration.

\section{Boundary Proximity and Breach Visibility}

Define a boundary metric $b(A)$
which increases as $A$ approaches closure regimes.

Breach-visible operators activate when:

\[
b(A)>\tau
\]

for a threshold $\tau$.

Computationally:

\begin{lstlisting}[basicstyle=\ttfamily\small]
if boundary_score(A) > tau:
  enable_reverse_ops()
\end{lstlisting}

This encodes the observability law:
reverse structure is typically suppressed
until closure pressure.

\section{Stability Detection}

A stable region is detected by reaching a fixed point:

\[
A_{n+1}=A_n.
\]

Computationally:

\begin{lstlisting}[basicstyle=\ttfamily\small]
detect_fixed_point(A, f, k):
  for i in range(k):
    A2 = f(A)
    if A2 == A:
      return true
    A = A2
  return false
\end{lstlisting}

Stability is structural.
It is not interpreted as success.

\section{How Collapse Occurs}

Collapse occurs when:
\begin{itemize}
  \item implementations are treated as truth,
  \item schedules are treated as prescriptions,
  \item outputs are treated as meanings,
  \item computation replaces admissibility.
\end{itemize}

Under these conditions,
execution becomes doctrine.

\section{Admissible Reading}

This demonstration permits the following reading:

\begin{quote}
Computational realization provides an executable interface
for constraint operators and admissibility cycles
without implying prediction, instruction, or ontology.
\end{quote}

\section{Stop Condition}

This demonstration stops at the point where:
\begin{itemize}
  \item code is treated as authority,
  \item outputs are treated as conclusions,
  \item implementations become governance,
  \item execution becomes interpretation.
\end{itemize}

Beyond this point,
computation collapses into narrative control.

\section{Conclusion}

Constraint relations can be implemented
as indexed narrowing operators
with seam traversal and derived visibility.

Execution supports inspection,
not explanation.

Nothing further is claimed.

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
